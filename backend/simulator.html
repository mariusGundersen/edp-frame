<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simulator</title>
  </head>
  <body>
    <canvas width="800" height="480"></canvas>
    <script type="module">
      import { compress, decompress } from "./heatshrink.js";
      const response = await fetch("./data");

      const data = new Uint8Array(await response.arrayBuffer());

      /**
       * @param {Uint8Array} input
       */
      function rle(input) {
        const getQuad = (i) =>
          input[i] |
          (input[i + 1] << 8) |
          (input[i + 2] << 16) |
          (input[i + 3] << 24);

        const histogram = new Map();
        for (let i = 0; i < input.length - 3; i++) {
          if (input[i] === input[i + 1]) continue;
          const quad = getQuad(i);
          histogram.set(quad, (histogram.get(quad) ?? 0) + 1);
        }

        const entries = [...histogram.entries()]
          .toSorted((a, b) => b[1] - a[1])
          .slice(0, 64);

        const expectedUsages = entries.map((a) => a[1]);
        const usages = new Array(64).fill(0);

        const quads = entries.map((a) => a[0]);

        const output = [
          ...quads.flatMap((q) => [
            q & 0xff,
            (q >> 8) & 0xff,
            (q >> 16) & 0xff,
            (q >> 24) & 0xff,
          ]),
        ];

        for (let i = output.length; i < 256; i++) {
          output[i] = 0;
        }
        let o = output.length;
        let i = 0;

        while (i < input.length) {
          const quadIndex = quads.indexOf(getQuad(i));

          if (quadIndex >= 0) {
            output[o++] = 64 + quadIndex;
            usages[quadIndex]++;
            i += 4;
            continue;
          }

          let repeats = 1;
          while (
            i + repeats < input.length &&
            input[i] === input[i + repeats] &&
            repeats < 128
          ) {
            repeats++;
          }
          if (repeats > 1) {
            output[o++] = 1 - repeats;
            output[o++] = input[i];
            i += repeats;
          } else {
            const from = i + 1;
            const headerPos = o++;
            while (i < input.length && i - from < 63) {
              if (input[i] === input[i + 1] && input[i] === input[i + 2]) break;
              if (quads.includes(getQuad(i))) break;
              output[o++] = input[i++];
            }
            output[headerPos] = i - from;
          }
        }

        console.log(
          "diff usages",
          expectedUsages.map((e, i) => e - usages[i]),
          expectedUsages,
          usages
        );

        return output;
      }

      function rld(input, size) {
        const output = new Uint8Array(size);
        let o = 0;
        let i = 256;
        const repeats = {};
        const actuals = {};
        while (o < size) {
          if (input[i] < 0) {
            repeats[1 - input[i]] ??= 0;
            repeats[1 - input[i]]++;
            for (let repeat = 1 - input[i++]; repeat > 0; repeat--) {
              output[o++] = input[i];
            }
            i++;
          } else if (input[i] >= 64) {
            const index = input[i] - 64;
            output[o++] = input[index * 4 + 0];
            output[o++] = input[index * 4 + 1];
            output[o++] = input[index * 4 + 2];
            output[o++] = input[index * 4 + 3];
            i++;
          } else {
            actuals[1 + input[i]] ??= 0;
            actuals[1 + input[i]]++;
            for (let actual = 1 + input[i++]; actual > 0; actual--) {
              output[o++] = input[i++];
            }
          }
        }
        console.log({ repeats, actuals });

        return output;
      }

      test([0, 1, 2, 3, 4, 5, 6, 7]);
      test(Array.from(new Array(256), (_, i) => i));
      test(data);

      const stream = new Blob([data])
        .stream()
        .pipeThrough(new CompressionStream("deflate"));
      let count = 0;
      for await (const chunk of stream) {
        count += chunk.length;
      }
      console.log(
        `deflate: from ${data.length} to ${count}, down to ${(
          (count / data.length) *
          100
        ).toFixed(0)}%`
      );
      //test(data.subarray(0, data.length / 2));
      //test(data.subarray(data.length / 2));

      function test(input) {
        const compressed = rle(input);
        const output = rld(compressed, input.length);
        if (input.length !== output.length)
          throw new Error(
            `Lengths don't match! ${input.length} !== ${output.length}`
          );
        for (let i = 0; i < input.length; i++) {
          if (input[i] !== output[i])
            throw new Error(
              `Mismatched at index ${i}, ${input[i]} !== ${output[i]}`
            );
        }
        console.log(
          `rle: from ${input.length} to ${compressed.length}, down to ${(
            (compressed.length / input.length) *
            100
          ).toFixed(0)}%`
        );
      }

      const compressed = compress(data);

      console.log(
        `heatshrink: from ${data.length} to ${compressed.length}, down to ${(
          (compressed.length / data.length) *
          100
        ).toFixed(0)}%`
      );

      const canvas = document.querySelector("canvas");
      const ctx = canvas.getContext("2d");
      const imgData = ctx.getImageData(0, 0, 800, 480);

      const pixels = new Uint32Array(imgData.data.buffer);

      console.log(800 * 480, pixels.length, data.length);

      for (let i = 0; i < 800 * 480; i++) {
        pixels[800 * 480 - i] =
          (data[Math.floor(i / 8)] >> (7 - (i % 8))) & (1 == 1)
            ? 0xff_ff_ff_ff
            : 0xff_00_00_00;
      }
      for (let i = 0; i < 800 * 480; i++) {
        pixels[800 * 480 - i] =
          (data[Math.floor(480 * 100 + i / 8)] >> (7 - (i % 8))) & (1 === 1)
            ? 0xff_00_00_ff
            : pixels[800 * 480 - i];
      }

      ctx.putImageData(imgData, 0, 0);
    </script>
  </body>
</html>
